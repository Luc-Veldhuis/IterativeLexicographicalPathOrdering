My comments on haskell:

- Parsing could be nicer using the Parsec library.

- helpers:
     flatten = concat <check>
     makeList n = [1..n] <check>
     containsTerm reductions term = or $ map (term ==) $ map result <check>
reductions
     copyTerm t n  = replicate n t <check>

- IterativeLexicographicalGenerators:
     generateVariables n = map Var [1..n] <check>
     generateVariablesOffset n o = map Var [(1+o)..(n+o)] <check>

     generatePutRule: why is the argument (Term (FunctionSymbol f) v)
instead of FunctionSymbol f ?
     This occurs several times, also the order is defined on Term
instead of FunctionSymbol.

     maybe it would be nice to have:
       star f = f { star = True }
       unstar f = f { star = False }

     then generatePutRule could become:

         generatePutRule f =
           let vars = (generateVariables $ arity f)
           in Fun f vars --> Fun (star f) vars

         generateSelectRules f =
           let vars = (generateVariables $ arity f)
           in map (\var -> Fun (star f) vars --> Var var) vars

         generateCopyRules greater f symbols =
           let vars = (generateVariables $ arity f)
               left = Fun (star f) vars
           in map (\g -> left --> Fun g $ relicate (arity g) left) $
filter (greater f) symbols

         splits :: [a] -> [([a],[a])]
         splits [] = []
         splits (x:list) = ([],x:list) :: map (\(l,r) -> (x:l,r)) $
splits list

         -- not ready yet
         generateLexicoRules f g=
           let vars_f = splits (generateVariables $ arity f - 1)
               vars_g = generateVariablesOffset (arity g) $ arity f
               left = (\(l,r) -> Fun (star f) (l ++ [Fun g vars_g] ++ r))
           in map (\(l,r) ->  left (l,r) --> Fun f (l ++ [Fun (star g) vars_g] ++
(replicate (length r) $ left (l,r)) ) $ vars_f

 You can introduce abbreviations, like

     class (Eq v, Ord v, Show v) => EOS v

Then you can use (EOS v, EOS f) => ...
